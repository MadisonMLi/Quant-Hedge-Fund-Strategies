# -*- coding: utf-8 -*-
"""Project 6_Bondprice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tRPQptyIusLCwI2YzY3NjThxrG2rikmr
"""

!pip install QuantLib==1.24

import QuantLib as ql
import pandas as pd
import numpy as np
from scipy.optimize import fsolve
from scipy.interpolate import CubicSpline
import matplotlib.pyplot as plt

print(ql.__version__)

def convertable_bond_pricer(spot_price,volatility,risk_free_rate):
    # assumptions
    calculation_date = ql.Date(22,2,2022)
    ql.Settings.instance().evaluationDate = calculation_date
    redemption = 100.00
    face_amount = 100.0
    conversion_price = 7.068
    conversion_ratio = 14.14827

    issue_date = ql.Date(30,1,2013)
    maturity_date = ql.Date(1,2,2033)

    settlement_days = 2
    calendar = ql.UnitedStates(ql.UnitedStates.GovernmentBond)
    coupon = 0.03
    frequency = ql.Semiannual
    tenor = ql.Period(frequency)

    day_count = ql.Thirty360(ql.Thirty360.BondBasis)
    accrual_convention = ql.Unadjusted
    payment_convention = ql.Unadjusted

    call_dates = [ql.Date(1,2,2019)]
    call_price = 100.0
    put_dates = [ql.Date(1,2,2019), ql.Date(1,2,2023), ql.Date(1,2,2028)]
    put_price = 100.0

    # assumptions
    dividend_yield = 0
    credit_spread_rate = 0.04

    callability_schedule = ql.CallabilitySchedule()

    for call_date in call_dates:
        callability_price  = ql.BondPrice(call_price,
                                        ql.BondPrice.Clean)
        callability_schedule.append(ql.Callability(callability_price,
                                            ql.Callability.Call,
                                            call_date))

    for put_date in put_dates:
        puttability_price = ql.BondPrice(put_price,
                                        ql.BondPrice.Clean)
        callability_schedule.append(ql.Callability(puttability_price,
                                                ql.Callability.Put,
                                                put_date))

    dividend_schedule = ql.DividendSchedule() # No dividends
    dividend_amount = dividend_yield*spot_price
    next_dividend_date = ql.Date(1,12,2004)
    dividend_amount = spot_price*dividend_yield
    for i in range(4):
        date = calendar.advance(next_dividend_date, 1, ql.Years)
        dividend_schedule.append(
            ql.FixedDividend(dividend_amount, date)
        )

    schedule = ql.Schedule(issue_date, maturity_date, tenor,
                       calendar, accrual_convention, accrual_convention,
                       ql.DateGeneration.Backward, False)

    credit_spread_handle = ql.QuoteHandle(ql.SimpleQuote(credit_spread_rate))
    exercise = ql.AmericanExercise(calculation_date, maturity_date)

    convertible_bond = ql.ConvertibleFixedCouponBond(exercise,
                                                    conversion_ratio,
                                                    dividend_schedule,
                                                    callability_schedule,
                                                    credit_spread_handle,
                                                    issue_date,
                                                    settlement_days,
                                                    [coupon],
                                                    day_count,
                                                    schedule,
                                                    redemption)

    spot_price_handle = ql.QuoteHandle(ql.SimpleQuote(spot_price))
    yield_ts_handle = ql.YieldTermStructureHandle(
        ql.FlatForward(calculation_date, risk_free_rate, day_count)
    )
    dividend_ts_handle = ql.YieldTermStructureHandle(
        ql.FlatForward(calculation_date, dividend_yield, day_count)
    )
    volatility_ts_handle = ql.BlackVolTermStructureHandle(
        ql.BlackConstantVol(calculation_date, calendar,volatility, day_count)
    )

    bsm_process = ql.BlackScholesMertonProcess(spot_price_handle,
                                            dividend_ts_handle,
                                            yield_ts_handle,
                                            volatility_ts_handle)
    time_steps = 1000
    engine = ql.BinomialConvertibleEngine(bsm_process, "crr", time_steps)
    convertible_bond.setPricingEngine(engine)
    return convertible_bond
    #return (convertible_bond.NPV(), convertible_bond.accruedAmount())

def conv_npv(spot_price,volatility,risk_free_rate):
    return convertable_bond_pricer(spot_price, volatility, risk_free_rate).NPV()

def conv_accrued(spot_price, volatility, risk_free_rate):
    return convertable_bond_pricer(spot_price, volatility, risk_free_rate).accruedAmount()

print(f"The npv is {conv_npv(spot_price=3.02, volatility= 0.3, risk_free_rate=0.04)}")
print(f"The accrued amount is {conv_accrued(spot_price=3.02, volatility= 0.3, risk_free_rate=0.04)}")

"""# Greeks"""

def DeltaAndGamma(spot_price, volatility, risk_free_rate):
    deltaS = spot_price*0.01
    vp = conv_npv(spot_price, volatility, risk_free_rate)
    vp1 = conv_npv(spot_price+deltaS, volatility, risk_free_rate)
    vp2 = conv_npv(spot_price-deltaS, volatility, risk_free_rate)
    delta = (vp1 - vp2)/(2* deltaS)
    gamma = (vp1 + vp2 - 2*vp)/(deltaS**2)

    return (delta, gamma)

def Vega (spot_price, volatility, risk_free_rate):
    deltaSig = volatility*0.01
    vp1 = conv_npv(spot_price, volatility+deltaSig, risk_free_rate)
    vp2 = conv_npv(spot_price, volatility-deltaSig, risk_free_rate)
    vega = (vp1 - vp2)/(2*deltaSig)
    return vega

def Rho(spot_price, volatility, risk_free_rate):
    deltaR = risk_free_rate*0.01
    vp1 = conv_npv(spot_price, volatility, risk_free_rate+deltaR)
    vp2 = conv_npv(spot_price, volatility, risk_free_rate-deltaR)
    rho = (vp1 - vp2)/(2*deltaR)
    return rho

print(f"The delta is {DeltaAndGamma(spot_price=3.02, volatility= 0.3, risk_free_rate=0.04)[0]}")
print(f"The gamma is {DeltaAndGamma(spot_price=3.02, volatility= 0.3, risk_free_rate=0.04)[1]}")
print(f"The vega is {Vega(spot_price=3.02, volatility= 0.3, risk_free_rate=0.04)}")
print(f"The rho is {Rho(spot_price=3.02, volatility= 0.3, risk_free_rate=0.04)}")

"""# bond floor curves"""

xls  = pd.ExcelFile("US Swap Curve 20230221.xlsx")
data = pd.read_excel(xls, 0 , skiprows=2, usecols = lambda x : 'Unnamed' not in x )
data.drop(data.iloc[:,6:], inplace = True, axis = 1)
data.dropna(inplace=True)
data

risk_yield_curve = data["Market Rate"] + 4
risk_yield_curve

def bootstrapping(ytm):
    mats = np.array([0.25,1,2,3,4,5,6,7,8,9,10,11,12,15,20,25,30])
    times = np.arange(.5, 30 + 0.4, 1/2)
    rates = np.array(ytm.T)
    cs = CubicSpline(mats,rates, bc_type = 'natural')
    yield_full = cs(times)
    return pd.Series(yield_full)

spotrate=bootstrapping(risk_yield_curve)

start_date=ql.Date(22,2,2022)
end_date=ql.Date(1,2,2033)
schedule = list(ql.Schedule(start_date,end_date,
            ql.Period(ql.Semiannual),
            ql.UnitedStates(0),
            ql.ModifiedFollowing,
            ql.ModifiedFollowing,
            ql.DateGeneration.Forward,
            False))
df = pd.DataFrame()
df['Dates'] = schedule
df['Spot'] = 0
df['Spot'][1:] = spotrate[:22]
df['Cashflow'] = 1.5
df.loc[22,'Cashflow'] += 100
df.loc[0,'Cashflow'] = 0
df['DCF'] = df['Cashflow']/((1+df['Spot']/100)**(df.index/2))
for i in df.index:
  df.loc[i,'Floor'] = np.sum(df.DCF[i:])*(1+df.loc[i,'Spot']/100)**(i/2)
print(df)

# df['Dates','Floor'].plot(style={'Dates': 'Floor'})
plt.plot(df.index, df['Floor'])
